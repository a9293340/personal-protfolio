<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æŠ€èƒ½ç‹€æ…‹ç®¡ç†ç³»çµ±æ¸¬è©¦</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #ffffff;
            min-height: 100vh;
            padding: 20px;
        }
        
        .test-container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .test-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .test-header h1 {
            color: #d4af37;
            font-size: 2rem;
            margin-bottom: 10px;
        }
        
        .control-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(26, 26, 46, 0.8);
            border-radius: 12px;
        }
        
        .control-button {
            padding: 10px 15px;
            background: #2980b9;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }
        
        .control-button:hover {
            background: #3498db;
            transform: translateY(-1px);
        }
        
        .control-button.danger {
            background: #e74c3c;
        }
        
        .control-button.danger:hover {
            background: #c0392b;
        }
        
        .stats-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: rgba(26, 26, 46, 0.8);
            border: 1px solid #d4af37;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #d4af37;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: #cccccc;
        }
        
        .skills-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .skill-category {
            background: rgba(26, 26, 46, 0.6);
            border-radius: 12px;
            padding: 20px;
        }
        
        .category-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            font-size: 1.1rem;
            font-weight: bold;
            color: #d4af37;
        }
        
        .category-icon {
            font-size: 1.3rem;
            margin-right: 10px;
        }
        
        .skill-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .skill-item:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateX(2px);
        }
        
        .skill-info {
            display: flex;
            align-items: center;
        }
        
        .skill-status {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
            transition: all 0.3s ease;
        }
        
        .skill-status.mastered {
            background: #d4af37;
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.6);
        }
        
        .skill-status.available {
            background: #2980b9;
            box-shadow: 0 0 8px rgba(41, 128, 185, 0.4);
        }
        
        .skill-status.learning {
            background: #27ae60;
            box-shadow: 0 0 8px rgba(39, 174, 96, 0.4);
            animation: pulse 2s infinite;
        }
        
        .skill-status.locked {
            background: #666666;
        }
        
        .skill-actions {
            display: flex;
            gap: 5px;
        }
        
        .skill-action-btn {
            padding: 2px 6px;
            font-size: 0.7rem;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .skill-action-btn.learn {
            background: #27ae60;
            color: white;
        }
        
        .skill-action-btn.master {
            background: #d4af37;
            color: black;
        }
        
        .skill-action-btn.reset {
            background: #e74c3c;
            color: white;
        }
        
        .skill-action-btn:hover {
            transform: scale(1.05);
        }
        
        .skill-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .log-panel {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .log-entry {
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            margin: 2px 0;
            padding: 2px 5px;
            border-left: 3px solid transparent;
        }
        
        .log-entry.info {
            color: #3498db;
            border-left-color: #3498db;
        }
        
        .log-entry.success {
            color: #27ae60;
            border-left-color: #27ae60;
        }
        
        .log-entry.warning {
            color: #f39c12;
            border-left-color: #f39c12;
        }
        
        .log-entry.error {
            color: #e74c3c;
            border-left-color: #e74c3c;
        }
        
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }
        
        @keyframes skill-unlock {
            0% {
                transform: scale(1);
                opacity: 0.4;
            }
            50% {
                transform: scale(1.2);
                opacity: 1;
            }
            100% {
                transform: scale(1);
                opacity: 0.8;
            }
        }
        
        @keyframes skill-master {
            0% {
                transform: scale(1);
                filter: brightness(1);
            }
            50% {
                transform: scale(1.3);
                filter: brightness(1.5);
            }
            100% {
                transform: scale(1);
                filter: brightness(1.2);
            }
        }
        
        .skill-item.status-change-unlock {
            animation: skill-unlock 0.8s ease-out;
        }
        
        .skill-item.status-change-master {
            animation: skill-master 1.2s ease-out;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <div class="test-header">
            <h1>ğŸ® æŠ€èƒ½ç‹€æ…‹ç®¡ç†ç³»çµ±æ¸¬è©¦</h1>
            <p>Step 2.1.4 - æ¸¬è©¦æŠ€èƒ½ç‹€æ…‹é‚è¼¯ã€å‹•ç•«æ•ˆæœå’ŒæŒä¹…åŒ–</p>
        </div>
        
        <div class="control-panel">
            <button class="control-button" onclick="initializeSystem()">åˆå§‹åŒ–ç³»çµ±</button>
            <button class="control-button" onclick="recalculateStates()">é‡æ–°è¨ˆç®—ç‹€æ…‹</button>
            <button class="control-button" onclick="simulateProgressPath()">æ¨¡æ“¬å­¸ç¿’è·¯å¾‘</button>
            <button class="control-button" onclick="testAnimations()">æ¸¬è©¦å‹•ç•«</button>
            <button class="control-button danger" onclick="resetAllStates()">é‡ç½®æ‰€æœ‰ç‹€æ…‹</button>
            <button class="control-button danger" onclick="clearStorage()">æ¸…é™¤å„²å­˜</button>
        </div>
        
        <div class="stats-panel" id="statsPanel">
            <!-- çµ±è¨ˆè³‡æ–™å°‡ç”± JavaScript å¡«å…… -->
        </div>
        
        <div class="skills-grid" id="skillsGrid">
            <!-- æŠ€èƒ½ç¶²æ ¼å°‡ç”± JavaScript å¡«å…… -->
        </div>
        
        <div class="log-panel">
            <h3 style="color: #d4af37; margin-bottom: 10px;">ğŸ” ç³»çµ±æ—¥èªŒ</h3>
            <div id="logContainer">
                <!-- æ—¥èªŒæ¢ç›®å°‡ç”± JavaScript å¡«å…… -->
            </div>
        </div>
    </div>

    <script type="module">
        // æ¨¡æ“¬å°å…¥ (åœ¨å¯¦éš›ç’°å¢ƒä¸­æœƒå¾æ¨¡çµ„å°å…¥)
        
        // æ¨¡æ“¬æŠ€èƒ½æ•¸æ“šé…ç½®
        const mockSkillsData = {
            metadata: {
                version: "2.1.4",
                totalSkills: 16
            },
            categories: {
                frontend: { name: "å‰ç«¯é–‹ç™¼é ˜åŸŸ", color: "#e74c3c", icon: "ğŸ¨" },
                backend: { name: "å¾Œç«¯å·¥ç¨‹é ˜åŸŸ", color: "#3498db", icon: "âš¡" },
                database: { name: "è³‡æ–™åº«å·¥ç¨‹é ˜åŸŸ", color: "#2ecc71", icon: "ğŸ—„ï¸" },
                devops: { name: "é›²ç«¯æœå‹™èˆ‡ DevOps", color: "#9b59b6", icon: "âš™ï¸" },
                ai: { name: "AI å·¥ç¨‹æ‡‰ç”¨é ˜åŸŸ", color: "#f39c12", icon: "ğŸ¤–" },
                architecture: { name: "ç³»çµ±æ¶æ§‹è¨­è¨ˆé ˜åŸŸ", color: "#1abc9c", icon: "ğŸ—ï¸" }
            },
            tree: {
                center: {
                    id: "backend-engineer-core",
                    name: "å¾Œç«¯å·¥ç¨‹å¸«",
                    category: "backend",
                    status: "mastered",
                    coordinates: { q: 0, r: 0 }
                },
                ring1: [
                    { id: "html-css-foundation", name: "HTML/CSS åŸºç¤", category: "frontend", status: "mastered", prerequisites: ["backend-engineer-core"] },
                    { id: "design-patterns-core", name: "è¨­è¨ˆæ¨¡å¼åŸºç¤", category: "architecture", status: "available", prerequisites: ["backend-engineer-core"] },
                    { id: "prompt-engineering-core", name: "Prompt Engineering", category: "ai", status: "available", prerequisites: ["backend-engineer-core"] },
                    { id: "version-control-systems", name: "ç‰ˆæœ¬æ§åˆ¶ç³»çµ±", category: "devops", status: "mastered", prerequisites: ["backend-engineer-core"] },
                    { id: "relational-databases-core", name: "é—œè¯å¼è³‡æ–™åº«", category: "database", status: "mastered", prerequisites: ["backend-engineer-core"] },
                    { id: "programming-languages", name: "ç¨‹å¼èªè¨€ç²¾é€š", category: "backend", status: "mastered", prerequisites: ["backend-engineer-core"] }
                ],
                ring2: [
                    { id: "javascript-advanced", name: "JavaScript é€²éš", category: "frontend", status: "locked", prerequisites: ["html-css-foundation"] },
                    { id: "system-architecture-design", name: "ç³»çµ±æ¶æ§‹è¨­è¨ˆ", category: "architecture", status: "locked", prerequisites: ["design-patterns-core"] },
                    { id: "contextual-understanding", name: "AIæƒ…å¢ƒç†è§£", category: "ai", status: "locked", prerequisites: ["prompt-engineering-core"] },
                    { id: "cicd-pipeline", name: "CI/CD æµæ°´ç·š", category: "devops", status: "available", prerequisites: ["version-control-systems"] },
                    { id: "nosql-databases", name: "NoSQL è³‡æ–™åº«", category: "database", status: "available", prerequisites: ["relational-databases-core"] },
                    { id: "web-frameworks", name: "Web é–‹ç™¼æ¡†æ¶", category: "backend", status: "available", prerequisites: ["programming-languages"] }
                ],
                ring3: [
                    { id: "fullstack-architect", name: "å…¨ç«¯æ¶æ§‹å¸«", category: "frontend", status: "locked", prerequisites: ["javascript-advanced"] },
                    { id: "solution-architect", name: "è§£æ±ºæ–¹æ¡ˆæ¶æ§‹å¸«", category: "architecture", status: "locked", prerequisites: ["system-architecture-design"] },
                    { id: "ai-solutions-expert", name: "AIè§£æ±ºæ–¹æ¡ˆå°ˆå®¶", category: "ai", status: "locked", prerequisites: ["contextual-understanding"] },
                    { id: "devops-architect", name: "DevOpsæ¶æ§‹å¸«", category: "devops", status: "locked", prerequisites: ["cicd-pipeline"] }
                ]
            }
        };

        // æ¨¡æ“¬ç‹€æ…‹ç®¡ç†å™¨ (ç°¡åŒ–ç‰ˆæœ¬)
        class MockSkillStateManager {
            constructor() {
                this.skillStates = new Map();
                this.listeners = {};
                this.storageKey = 'skillTree_userProgress_test';
            }

            setSkillTreeData(data) {
                this.skillTreeData = data;
                this.initializeSkillStates();
                this.calculateAllStates();
                this.emit('skill-states-initialized', { totalSkills: this.skillStates.size });
            }

            initializeSkillStates() {
                const allNodes = this.collectAllSkillNodes();
                allNodes.forEach(node => {
                    if (!this.skillStates.has(node.id)) {
                        this.skillStates.set(node.id, {
                            id: node.id,
                            status: node.status || 'locked',
                            level: node.level || 1,
                            progress: 0,
                            unlockedAt: node.status === 'mastered' ? Date.now() : null,
                            lastUpdated: Date.now()
                        });
                    }
                });
            }

            collectAllSkillNodes() {
                const nodes = [];
                const tree = this.skillTreeData.tree;
                if (tree.center) nodes.push(tree.center);
                ['ring1', 'ring2', 'ring3'].forEach(ring => {
                    if (tree[ring]) nodes.push(...tree[ring]);
                });
                return nodes;
            }

            calculateAllStates() {
                const allNodes = this.collectAllSkillNodes();
                let hasChanges = true;
                let rounds = 0;

                while (hasChanges && rounds < 5) {
                    hasChanges = false;
                    rounds++;

                    allNodes.forEach(node => {
                        const newStatus = this.calculateSkillStatus(node);
                        const currentState = this.skillStates.get(node.id);
                        if (currentState && currentState.status !== newStatus) {
                            this.updateSkillStatus(node.id, newStatus, false);
                            hasChanges = true;
                        }
                    });
                }

                this.emit('skill-states-recalculated', { rounds });
            }

            calculateSkillStatus(node) {
                const currentState = this.skillStates.get(node.id);
                if (!currentState) return 'locked';

                if (currentState.status === 'mastered') return 'mastered';

                const prerequisites = node.prerequisites || [];
                if (prerequisites.length === 0) return currentState.status;

                const prerequisitesMet = prerequisites.every(prereqId => {
                    const prereqState = this.skillStates.get(prereqId);
                    return prereqState && prereqState.status === 'mastered';
                });

                if (prerequisitesMet) {
                    if (currentState.status === 'locked') return 'available';
                    return currentState.status;
                } else {
                    if (currentState.status === 'available' || currentState.status === 'learning') {
                        return 'locked';
                    }
                    return currentState.status;
                }
            }

            updateSkillStatus(skillId, newStatus, emitEvent = true) {
                const currentState = this.skillStates.get(skillId);
                if (!currentState || currentState.status === newStatus) return false;

                const oldStatus = currentState.status;
                currentState.status = newStatus;
                currentState.lastUpdated = Date.now();

                if (newStatus === 'mastered' && oldStatus !== 'mastered') {
                    currentState.unlockedAt = Date.now();
                }

                if (emitEvent) {
                    this.emit('skill-status-changed', {
                        skillId,
                        oldStatus,
                        newStatus,
                        state: currentState
                    });
                }

                this.persistState();
                return true;
            }

            getSkillState(skillId) {
                return this.skillStates.get(skillId);
            }

            getStatesCount() {
                const counts = { mastered: 0, available: 0, learning: 0, locked: 0 };
                for (const state of this.skillStates.values()) {
                    counts[state.status]++;
                }
                return counts;
            }

            getProgressStats() {
                const states = this.getStatesCount();
                const total = this.skillStates.size;
                return {
                    total,
                    mastered: states.mastered,
                    available: states.available,
                    learning: states.learning,
                    locked: states.locked,
                    masteredPercentage: total > 0 ? Math.round((states.mastered / total) * 100) : 0,
                    unlockedPercentage: total > 0 ? Math.round(((states.mastered + states.available + states.learning) / total) * 100) : 0
                };
            }

            persistState() {
                try {
                    const stateData = {
                        version: '2.1.4',
                        timestamp: Date.now(),
                        states: Array.from(this.skillStates.entries()).map(([id, state]) => ({ id, ...state }))
                    };
                    localStorage.setItem(this.storageKey, JSON.stringify(stateData));
                    log('ç‹€æ…‹å·²ä¿å­˜åˆ°æœ¬åœ°å­˜å„²', 'success');
                } catch (error) {
                    log('ä¿å­˜ç‹€æ…‹å¤±æ•—: ' + error.message, 'error');
                }
            }

            loadPersistedState() {
                try {
                    const savedData = localStorage.getItem(this.storageKey);
                    if (savedData) {
                        const stateData = JSON.parse(savedData);
                        if (stateData.states) {
                            stateData.states.forEach(state => {
                                this.skillStates.set(state.id, state);
                            });
                            log(`å¾æœ¬åœ°å­˜å„²è¼‰å…¥ ${stateData.states.length} å€‹æŠ€èƒ½ç‹€æ…‹`, 'info');
                        }
                    }
                } catch (error) {
                    log('è¼‰å…¥ç‹€æ…‹å¤±æ•—: ' + error.message, 'error');
                }
            }

            clearPersistedState() {
                localStorage.removeItem(this.storageKey);
                log('æ¸…é™¤æœ¬åœ°å­˜å„²çš„ç‹€æ…‹æ•¸æ“š', 'warning');
            }

            resetAllSkillStates() {
                const allNodes = this.collectAllSkillNodes();
                allNodes.forEach(node => {
                    const initialStatus = node.status || 'locked';
                    this.skillStates.set(node.id, {
                        id: node.id,
                        status: initialStatus,
                        level: node.level || 1,
                        progress: 0,
                        unlockedAt: initialStatus === 'mastered' ? Date.now() : null,
                        lastUpdated: Date.now()
                    });
                });
                this.persistState();
                this.calculateAllStates();
                this.emit('skill-states-reset');
                log('æ‰€æœ‰æŠ€èƒ½ç‹€æ…‹å·²é‡ç½®', 'warning');
            }

            on(event, callback) {
                if (!this.listeners[event]) this.listeners[event] = [];
                this.listeners[event].push(callback);
            }

            emit(event, data) {
                if (this.listeners[event]) {
                    this.listeners[event].forEach(callback => callback(data));
                }
            }
        }

        // å…¨å±€è®Šé‡
        let stateManager;

        // æ—¥èªŒå‡½æ•¸
        function log(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${timestamp}] ${message}`;
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        // åˆå§‹åŒ–ç³»çµ±
        function initializeSystem() {
            log('é–‹å§‹åˆå§‹åŒ–æŠ€èƒ½ç‹€æ…‹ç®¡ç†ç³»çµ±', 'info');
            
            stateManager = new MockSkillStateManager();
            
            // è¼‰å…¥æŒä¹…åŒ–ç‹€æ…‹
            stateManager.loadPersistedState();
            
            // è¨­ç½®æŠ€èƒ½æ•¸æ“š
            stateManager.setSkillTreeData(mockSkillsData);
            
            // ç¶å®šäº‹ä»¶
            stateManager.on('skill-status-changed', (event) => {
                log(`æŠ€èƒ½ç‹€æ…‹è®ŠåŒ–: ${event.skillId} (${event.oldStatus} -> ${event.newStatus})`, 'success');
                animateSkillStatusChange(event.skillId, event.oldStatus, event.newStatus);
                updateSkillsDisplay();
                updateStatsDisplay();
            });
            
            stateManager.on('skill-states-recalculated', (event) => {
                log(`ç‹€æ…‹é‡æ–°è¨ˆç®—å®Œæˆ (${event.rounds} è¼ª)`, 'info');
                updateSkillsDisplay();
                updateStatsDisplay();
            });
            
            stateManager.on('skill-states-reset', () => {
                log('æ‰€æœ‰æŠ€èƒ½ç‹€æ…‹å·²é‡ç½®', 'warning');
                updateSkillsDisplay();
                updateStatsDisplay();
            });
            
            // åˆå§‹åŒ–é¡¯ç¤º
            updateSkillsDisplay();
            updateStatsDisplay();
            
            log('æŠ€èƒ½ç‹€æ…‹ç®¡ç†ç³»çµ±åˆå§‹åŒ–å®Œæˆ', 'success');
        }

        // æ›´æ–°çµ±è¨ˆé¡¯ç¤º
        function updateStatsDisplay() {
            const stats = stateManager.getProgressStats();
            const statsPanel = document.getElementById('statsPanel');
            
            statsPanel.innerHTML = `
                <div class="stat-card">
                    <div class="stat-value">${stats.total}</div>
                    <div class="stat-label">ç¸½æŠ€èƒ½</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${stats.mastered}</div>
                    <div class="stat-label">å·²æŒæ¡</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${stats.available}</div>
                    <div class="stat-label">å¯å­¸ç¿’</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${stats.learning}</div>
                    <div class="stat-label">å­¸ç¿’ä¸­</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${stats.locked}</div>
                    <div class="stat-label">æœªè§£é–</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${stats.masteredPercentage}%</div>
                    <div class="stat-label">æŒæ¡ç‡</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${stats.unlockedPercentage}%</div>
                    <div class="stat-label">è§£é–ç‡</div>
                </div>
            `;
        }

        // æ›´æ–°æŠ€èƒ½é¡¯ç¤º
        function updateSkillsDisplay() {
            const skillsGrid = document.getElementById('skillsGrid');
            const categories = {};
            
            // æ”¶é›†æ‰€æœ‰æŠ€èƒ½ä¸¦æŒ‰é¡åˆ¥åˆ†çµ„
            const allNodes = [];
            const tree = mockSkillsData.tree;
            if (tree.center) allNodes.push(tree.center);
            ['ring1', 'ring2', 'ring3'].forEach(ring => {
                if (tree[ring]) allNodes.push(...tree[ring]);
            });
            
            allNodes.forEach(node => {
                if (!categories[node.category]) {
                    categories[node.category] = [];
                }
                categories[node.category].push(node);
            });
            
            // ç”Ÿæˆ HTML
            skillsGrid.innerHTML = Object.entries(categories).map(([category, nodes]) => {
                const categoryInfo = mockSkillsData.categories[category];
                
                return `
                    <div class="skill-category">
                        <div class="category-header">
                            <span class="category-icon">${categoryInfo.icon}</span>
                            <span>${categoryInfo.name}</span>
                        </div>
                        ${nodes.map(node => {
                            const state = stateManager.getSkillState(node.id);
                            const status = state ? state.status : 'locked';
                            
                            return `
                                <div class="skill-item" data-skill-id="${node.id}">
                                    <div class="skill-info">
                                        <div class="skill-status ${status}"></div>
                                        <span class="skill-name">${node.name}</span>
                                    </div>
                                    <div class="skill-actions">
                                        <button class="skill-action-btn learn" 
                                                onclick="learnSkill('${node.id}')"
                                                ${status === 'locked' || status === 'mastered' ? 'disabled' : ''}>
                                            å­¸ç¿’
                                        </button>
                                        <button class="skill-action-btn master" 
                                                onclick="masterSkill('${node.id}')"
                                                ${status === 'locked' || status === 'mastered' ? 'disabled' : ''}>
                                            æŒæ¡
                                        </button>
                                        <button class="skill-action-btn reset" 
                                                onclick="resetSkill('${node.id}')">
                                            é‡ç½®
                                        </button>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
            }).join('');
        }

        // å‹•ç•«æŠ€èƒ½ç‹€æ…‹è®ŠåŒ–
        function animateSkillStatusChange(skillId, oldStatus, newStatus) {
            const skillElement = document.querySelector(`[data-skill-id="${skillId}"]`);
            if (!skillElement) return;
            
            // æ¸…é™¤èˆŠçš„å‹•ç•«é¡
            skillElement.classList.remove('status-change-unlock', 'status-change-master');
            
            // æ·»åŠ é©ç•¶çš„å‹•ç•«é¡
            if (newStatus === 'mastered' && oldStatus !== 'mastered') {
                skillElement.classList.add('status-change-master');
            } else if (newStatus === 'available' && oldStatus === 'locked') {
                skillElement.classList.add('status-change-unlock');
            }
            
            // æ¸…é™¤å‹•ç•«é¡
            setTimeout(() => {
                skillElement.classList.remove('status-change-unlock', 'status-change-master');
            }, 1200);
        }

        // æŠ€èƒ½äº¤äº’å‡½æ•¸
        function learnSkill(skillId) {
            const currentState = stateManager.getSkillState(skillId);
            if (currentState && currentState.status === 'available') {
                stateManager.updateSkillStatus(skillId, 'learning');
            }
        }

        function masterSkill(skillId) {
            const currentState = stateManager.getSkillState(skillId);
            if (currentState && (currentState.status === 'available' || currentState.status === 'learning')) {
                stateManager.updateSkillStatus(skillId, 'mastered');
                stateManager.calculateAllStates();
            }
        }

        function resetSkill(skillId) {
            const allNodes = stateManager.collectAllSkillNodes();
            const node = allNodes.find(n => n.id === skillId);
            if (node) {
                const initialStatus = node.status || 'locked';
                stateManager.updateSkillStatus(skillId, initialStatus);
                stateManager.calculateAllStates();
            }
        }

        // æ§åˆ¶é¢æ¿å‡½æ•¸
        function recalculateStates() {
            if (!stateManager) {
                log('è«‹å…ˆåˆå§‹åŒ–ç³»çµ±', 'warning');
                return;
            }
            stateManager.calculateAllStates();
            log('ç‹€æ…‹é‡æ–°è¨ˆç®—å®Œæˆ', 'info');
        }

        function simulateProgressPath() {
            if (!stateManager) {
                log('è«‹å…ˆåˆå§‹åŒ–ç³»çµ±', 'warning');
                return;
            }
            
            log('é–‹å§‹æ¨¡æ“¬å­¸ç¿’è·¯å¾‘', 'info');
            
            // æ¨¡æ“¬å­¸ç¿’åºåˆ—
            const learningPath = [
                'design-patterns-core',
                'system-architecture-design',
                'prompt-engineering-core',
                'contextual-understanding'
            ];
            
            let delay = 1000;
            learningPath.forEach((skillId, index) => {
                setTimeout(() => {
                    masterSkill(skillId);
                    log(`è‡ªå‹•æŒæ¡æŠ€èƒ½: ${skillId}`, 'info');
                }, delay * (index + 1));
            });
        }

        function testAnimations() {
            log('æ¸¬è©¦å‹•ç•«æ•ˆæœ', 'info');
            
            const testSkills = ['html-css-foundation', 'version-control-systems'];
            testSkills.forEach(skillId => {
                animateSkillStatusChange(skillId, 'available', 'mastered');
            });
        }

        function resetAllStates() {
            if (!stateManager) {
                log('è«‹å…ˆåˆå§‹åŒ–ç³»çµ±', 'warning');
                return;
            }
            stateManager.resetAllSkillStates();
        }

        function clearStorage() {
            if (!stateManager) {
                log('è«‹å…ˆåˆå§‹åŒ–ç³»çµ±', 'warning');
                return;
            }
            stateManager.clearPersistedState();
        }

        // é é¢è¼‰å…¥æ™‚åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            log('é é¢è¼‰å…¥å®Œæˆï¼Œæº–å‚™åˆå§‹åŒ–ç³»çµ±', 'info');
            initializeSystem();
        });

        // å°å‡ºå‡½æ•¸ä¾›æŒ‰éˆ•ä½¿ç”¨
        window.initializeSystem = initializeSystem;
        window.recalculateStates = recalculateStates;
        window.simulateProgressPath = simulateProgressPath;
        window.testAnimations = testAnimations;
        window.resetAllStates = resetAllStates;
        window.clearStorage = clearStorage;
        window.learnSkill = learnSkill;
        window.masterSkill = masterSkill;
        window.resetSkill = resetSkill;
    </script>
</body>
</html>